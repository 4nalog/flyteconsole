import { useContext, useEffect, useState } from 'react';

import { createDebugLogger } from 'common/log';
import { CacheContext, getCacheKey } from 'components/Cache';
import { useAPIContext } from 'components/data/apiContext';
import { NotAuthorizedError } from 'errors';
import { FetchableData, FetchFn } from './types';

const log = createDebugLogger('useFetchableData');

interface FetchState<T> {
    promise: Promise<T>;
    key?: string;
}

export interface FetchableDataConfig<T, DataType> {
    autoFetch?: boolean;
    useCache?: boolean;
    defaultValue: T;
    debugName?: string;
    doFetch: FetchFn<T, DataType>;
}

function isHashableInput(value: any): value is object | string {
    return (
        typeof value === 'object' ||
        typeof value === 'string' ||
        typeof value === 'symbol'
    );
}

export function useFetchableData<T, DataType extends object | string>(
    config: FetchableDataConfig<T, DataType>,
    data: DataType
): FetchableData<T>;
export function useFetchableData<T, DataType = never>(
    config: FetchableDataConfig<T, DataType>,
    data?: DataType
): FetchableData<T>;
/** A generic data-fetching hook that manages the state and functionality
 * associated with doing doing some asynchronous work that results in data to
 * be used in the component
 * @param data An optional string/object that is data to be used during the
 * fetch operation. Changing this value will trigger a new fetch operation.
 * @param config A configuration object holding the implementation details
 * @param config.autoFetch (Optional, default = true) Whether to trigger fetch()
 * immediately.
 * @param config.debugName A name to prepend to any debug messages generated by
 * this hook. Useful for separating log messages when using mutliple fetch hooks
 * @param config.defaultValue The value to be used before the first fetch
 * @param config.doFetch The work function to use for getting the data
 */
export function useFetchableData<T extends object, DataType>(
    config: FetchableDataConfig<T, DataType>,
    data: DataType
): FetchableData<T> {
    const cacheKey = isHashableInput(data) ? getCacheKey(data) : undefined;
    const {
        autoFetch = true,
        useCache: allowCache = false,
        debugName = '',
        defaultValue,
        doFetch
    } = config;

    const [lastError, setLastError] = useState<Error | null>(null);
    const [loading, setLoading] = useState(false);
    const [fetchState, setFetchState] = useState<FetchState<T> | null>(null);
    const [hasLoaded, setHasLoaded] = useState(false);
    const [value, setValue] = useState<T>(defaultValue);
    const cache = useContext(CacheContext);
    const apiContext = useAPIContext();

    let cancelled = false;
    const cancel = () => {
        cancelled = true;
    };

    const onValue = (newValue: T) => {
        let mergedValue = newValue;
        if (allowCache) {
            if (cacheKey === undefined) {
                log(
                    `${debugName} failed to cache value. Unexpected empty cache key`
                );
            } else {
                mergedValue = cache.mergeValue(cacheKey, newValue) as T;
            }
        }
        if (cancelled) {
            return mergedValue;
        }
        setValue(mergedValue);
        setFetchState(null);
        setHasLoaded(true);
        setLoading(false);
        return mergedValue;
    };

    const onError = (error: Error) => {
        if (error instanceof NotAuthorizedError) {
            apiContext.loginStatus.setExpired(true);
        }
        if (cancelled) {
            return Promise.reject(error);
        }
        setLastError(error instanceof Error ? error : new Error(error));
        setFetchState(null);
        setLoading(false);
        return Promise.resolve(defaultValue);
    };

    const fetch = async ({ force } = { force: false }) => {
        if (fetchState && fetchState.key === cacheKey) {
            log(`${debugName} Fetch already in progress, skipping`);
            return fetchState.promise;
        }

        setLastError(null);

        // If caching is enabled and this is not a force-refresh, we can check
        // for a cached value
        if (!force && allowCache && cacheKey !== undefined) {
            const cachedValue = cache.get(cacheKey) as T | undefined;
            if (cachedValue !== undefined) {
                log(
                    `${debugName} found cached value for hash ${cacheKey.toString()}`
                );
                return onValue(cachedValue);
            }
        }

        setLoading(true);

        const newFetchPromise = doFetch(data, value).then(onValue, onError);

        setFetchState({ promise: newFetchPromise, key: cacheKey });
        return newFetchPromise;
    };

    useEffect(
        () => {
            setFetchState(null);
            setLastError(null);
            setValue(defaultValue);
            setLoading(false);
            setHasLoaded(false);
        },
        cacheKey === undefined ? [] : [cacheKey]
    );

    // We initiate auto-fetch separately because we want it to run *after*
    // the reset occurs in the above effect. Otherwise doFetch will use a stale
    // `value` when invoking the passed fetch function.
    useEffect(() => {
        if (!hasLoaded && autoFetch) {
            fetch();
        }
        return cancel;
    }, [autoFetch, hasLoaded, cacheKey]);

    return { debugName, fetch, lastError, loading, hasLoaded, value };
}
